const interviewQuestion = [
    {
        question: 'Делегування подій',
        answer: 'Ідея в тому, що якщо у нас є багато елементів, які обробляються подібним чином, то замість того, щоб призначати обробник кожному з них, ми ставимо один обробник на їхнього спільного предка.У обробнику ми отримуємо event.target, щоб побачити, де насправді сталася подія і обробити її.',
        URL: 'https://uk.javascript.info/event-delegation'
    },
    {
        question: 'Навести приклад одного зі способів роботи з делегування подій',
        answer: 'Ідея в тому, що якщо у нас є багато елементів, які обробляються подібним чином, то замість того, щоб призначати обробник кожному з них, ми ставимо один обробник на їхнього спільного предка.У обробнику ми отримуємо event.target, щоб побачити, де насправді сталася подія і обробити її. 1)дії в розмітці. 2) Шаблон “поведінки”. 3) Поведінка: Перемикач',
        URL: 'https://uk.javascript.info/event-delegation'
    },
    {
        question: 'Поясніть, як працює прототипне успадкування',
        answer: 'У програмуванні ми часто хочемо щось взяти і доповнити чи розширити.Наприклад, ми маємо об’єкт user з його властивостями та методами, і хочемо створити admin та guest як дещо змінені варіанти об’єкта user.Тобто ми хочемо повторно використовувати те, що ми маємо в user, але також додати ще власні методи і властивості.Інакше кажучи, просто хочемо збудувати новий об’єкт поверх того, що існує. Коли ми зчитуємо якусь властивість об’єкта object, але її не має, JavaScript автоматично бере її з прототипу. Якщо animal має багато корисних властивостей та методів, вони стають автоматично ( __proto__: animal) доступними для rabbit. Такі властивості називаються “успадкованими”. В програмуванні це називається “успадкування через прототипи”.В JavaScript, об’єкти мають спеціальну приховану властивість [[Prototype]] (як зазначено в специфікаціях мови), яка може приймати значення: або null, або мати посилання на інший об’єкт. Цей об’єкт називається “прототип”:',
        URL: 'https://uk.javascript.info/prototype-inheritance'
    },
    {
        question: 'Яка різниця між змінною, яка є: нульовою, невизначеною чи неоголошеною? Як би ви перевірили будь- який із цих станів ?',
        answer: 'null — тип з єдиним значенням null, який означає “пусто” або “не існує”, undefined — тип з єдиним значенням undefined, який означає “не присвоєно”. треба зазначити typeof null == "object" // помилка в мові, Значення null та undefined особливі: вони рівні == лише самим собі і не рівні нічому іншому. Единственно правильным методом выяснения значения null является строгое сравнение переменной с объектом null: x === null, null == undefined// true. null == 0; // false, null< 0;  // false, null > 0; // false, null >= 0; // true (!), null <= 0; // true (!),Неоголошена буде як is not defined якщо через typeof nj undefined',
        URL: 'https://highload.today/null-v-javascript/#4'
    },
    {
        question: 'Що таке Замикання, і як/навіщо його використовувати?',
        answer: 'Замикання – це функція, яка запам’ятовує свої зовнішні змінні та може отримати до них доступ. У деяких мовах це зовсім неможливо, або функція має бути написана особливим чином. Але, як пояснювалося вище, в JavaScript замикання для функції – це природньо і не потребує жодних зусиль (є лише один виняток, який ми розглянемо у Синтаксис "new Function").Тобто: функції автоматично запам’ятовують, де вони були створені, використовуючи приховану властивість [[Environment]], а потім їхній код може отримати доступ до зовнішніх змінних. Всі функції в JavaScript є замиканнями. Коли функція виконується, на початку виклику автоматично створюється нове лексичне середовище для зберігання локальних змінних та параметрів виклику.Під час виклику функції у нас є два лексичні середовища: внутрішнє (для виклику функції) і зовнішнє (глобальне): Внутрішнє лексичне середовище відповідає поточному виконанню функції. Зовнішнє лексичне середовище – це глобальне лексичне середовище. У ньому є свої змінні та сама функції.Внутрішнє лексичне середовище має посилання на зовнішнє. Коли код хоче отримати доступ до змінної – спочатку шукає її у внутрішньому лексичному середовищі, потім у зовнішньому, і так далі поки не дійде до глобального.',
        URL: 'https://uk.javascript.info/closure'
    },
    {
        question: 'Які мовні конструкції ви використовуєте для ітерації властивостей об’єкта та елемента масиву',
        answer: 'Для об\'єктів: цикли for - for(властивість var в obj) { console.log(property); }.Однак це також буде повторювати його успадковані властивості, і ви додасте перевірку obj.hasOwnProperty(property) перед його використанням. Object.keys() - Object.keys(obj).forEach(функція(властивість) { ... }).Object.keys() — це статичний метод, який перераховує всі перелічувані властивості об’єкта, який ви йому передаєте. Object.getOwnPropertyNames() - Object.getOwnPropertyNames(obj).forEach(функція(властивість) { ... }).Object.getOwnPropertyNames() — це статичний метод, який перераховує всі перераховані та неперераховані властивості об’єкта, який ви йому передаєте.  Для масивів: цикли for - for (var i = 0; i < arr.length; i++).Поширеною помилкою тут є те, що var знаходиться в області видимості функції, а не в області видимості блоку, і здебільшого вам потрібна змінна ітератора з областю блоку.ES2015 представляє let, який має блочну область, і рекомендовано використовувати його замість цього.Отже, це стає: для (нехай i = 0; i < arr.length; i++). forEach - arr.forEach(функція(el, index) { ... }).Ця конструкція іноді може бути зручнішою, оскільки вам не потрібно використовувати індекс, якщо вам потрібні лише елементи масиву.Існують також усі та деякі методи, які дозволять вам завершити ітерацію достроково. У більшості випадків я віддаю перевагу методу.forEach, але це дійсно залежить від того, що ви намагаєтеся зробити.Цикли for забезпечують більшу гнучкість, наприклад передчасне завершення циклу за допомогою break або збільшення ітератора більше одного разу на цикл.',
        URL: 'https://www.fullstack.cafe/interview-questions/javascript'
    },
    {
        question: 'Чи можете ви описати основну різницю між циклом Array.forEach() і методами Array.map() і чому ви б вибрали один проти іншого',
        answer: 'Основна відмінність між map і forEach полягає в тому, що метод map повертає новий масив, застосовуючи функцію зворотного виклику до кожного елемента масиву, тоді як метод forEach нічого не повертає. Ви можете використовувати метод forEach для зміни вихідного масиву, але насправді це не той спосіб, у який він призначений.Метод forEach() нічого не повертає, тому тут не можна застосувати техніку ланцюжка методів. За допомогою методу map() ми можемо ланцюгувати інші методи екземплярів масиву, тобто повернуте значення методу map() викликає наступний метод у ланцюжку. Метод forEach() викликає передану функцию callback один раз для кажного елемента; forEach Не виконується для порожніх елементів. MAP Не змінює вихідний масив. Метод map викликає передану функцию callback один раз для кажного елемента, по порядку й створює новий масив з результатів її викликів.',
        URL: 'https://www.geeksforgeeks.org/difference-between-foreach-and-map-loop-in-javascript/'
    },
    {
        question: 'Який типовий випадок використання анонімних функцій',
        answer: 'Функція — це набір операторів, які приймають вхідні дані, виконують певні обчислення та видають вихідні дані. Анонімна функція працює так само, як і звичайна функція, але вони відрізняються за синтаксисом. Анонімна функція — це функція, яка не має жодного імені. Тобто ми використовуємо лише ключове слово function без назви функції. Анонімна функція недоступна після її початкового створення, доступ до неї можливий лише за допомогою змінної, у якій вона зберігається як функція як значення. Анонімна функція також може мати кілька аргументів, але лише один вираз. Можемо використовувати анонімну функцію як самовикликаючу функцію(спеціальну функцію, яка викликається одразу після її оголошення, а також не має жодного імені),(() => {console.log("GeeksforGeeks....!");}) (); Частно використовують анонімну функцію у змінній( щоб надрукувати наш результат =викличемо цю змінну). Анонімна функція недоступна після її початкового створення, доступ до неї можливий лише за допомогою змінної, у якій вона зберігається як функція як значення. Анонімні функції використовуються тоді, коли функціональність, що міститься в них, не потребує назви і може обмежитися використанням короткого терміну. Найчастіше вони застосовуються при замиканні.',
        URL: 'https://www.geeksforgeeks.org/what-is-a-typical-use-case-for-anonymous-functions-in-javascript/'
    },
    {
        question: 'Яка різниця між host об’єктами та native об’єктами',
        answer: 'native objects - Це стандартні глобальні об’єкти javascript, які є однаковими та надаються самим javascript. Вони доступні для всіх користувачів у всьому світі. _String(), Array(), Number(), false, “Hello World” Хост- об’єкти - Це специфічні для хоста(середовища) об’єкти JavaScript, які відрізняються від одного середовища до іншого.   Об’єкти, запропоновані одним середовищем, можуть не бути присутніми в іншому середовищі. Найвідомішим середовищем буде веб - браузер, але це може бути й інша платформа. Основними об’єктами, створеними у веб - браузері, можуть бути вікно або документ консоль, навігатор, NodeList. Тобто  three objects: Host, Native, Custom - це той що розробник вже налаштував.',
        URL: 'https://www.geeksforgeeks.org/what-is-the-difference-between-host-objects-and-native-objects/'
    },
    {
        question: 'Напишіть вираз функції, що негайно викликається (immediately invoked function expression)',
        answer: '(() => {console.log("GeeksforGeeks....!");}) ()',
        URL: 'https://codeburst.io/javascript-what-the-heck-is-an-immediately-invoked-function-expression-a0ed32b66c18'
    },
    {
        question: 'Створіть цикл for, який виконує до 100 ітерацій, виводячи "fizz" із числами, кратними 3, "buzz" із числами, кратними 5, і "fizzbuzz" із числами, кратними 3 і 5',
        answer: 'for (var x = 1; x <= 100; x++) { if(x % 3 == 0 && x % 5 == 0) { document.write("pingpong");} else { if(x % 3 == 0) { document.write("ping");} if (x % 5 == 0) {document.write("pong");}}document.write(x);document.write("<br>");}​',
        URL: 'http://jsfiddle.net/05fmevuz/13/'
    },
    {
        question: 'Що поверне console.log("hello" || "world") console.log("foo" && "bar")',
        answer: 'hello// перший true, bar якщо всі true повертає останній',
        URL: 'https://uk.javascript.info/logical-operators'
    },
];



// localStorage.setItem(interviewQuestion, interviewQuestion);

// if (localStorage.getItem('interviewQuestion')) {
//     <List list={localStorage.getItem('interviewQuestion')} />;
// } else {
//     <List list={interviewQuestion} />;


export default interviewQuestion;