const interviewQuestion = [
    {
        question: 'Делегування подій',
        answer: 'Ідея в тому, що якщо у нас є багато елементів, які обробляються подібним чином, то замість того, щоб призначати обробник кожному з них, ми ставимо один обробник на їхнього спільного предка.У обробнику ми отримуємо event.target, щоб побачити, де насправді сталася подія і обробити її.',
        URL: 'https://uk.javascript.info/event-delegation'
    },
    {
        question: 'Навести приклад одного зі способів роботи з делегування подій',
        answer: 'Ідея в тому, що якщо у нас є багато елементів, які обробляються подібним чином, то замість того, щоб призначати обробник кожному з них, ми ставимо один обробник на їхнього спільного предка.У обробнику ми отримуємо event.target, щоб побачити, де насправді сталася подія і обробити її. 1)дії в розмітці. 2) Шаблон “поведінки”. 3) Поведінка: Перемикач',
        URL: 'https://uk.javascript.info/event-delegation'
    },
    {
        question: 'Поясніть, як працює прототипне успадкування',
        answer: 'У програмуванні ми часто хочемо щось взяти і доповнити чи розширити.Наприклад, ми маємо об’єкт user з його властивостями та методами, і хочемо створити admin та guest як дещо змінені варіанти об’єкта user.Тобто ми хочемо повторно використовувати те, що ми маємо в user, але також додати ще власні методи і властивості.Інакше кажучи, просто хочемо збудувати новий об’єкт поверх того, що існує. Коли ми зчитуємо якусь властивість об’єкта object, але її не має, JavaScript автоматично бере її з прототипу. Якщо animal має багато корисних властивостей та методів, вони стають автоматично ( __proto__: animal) доступними для rabbit. Такі властивості називаються “успадкованими”. В програмуванні це називається “успадкування через прототипи”.В JavaScript, об’єкти мають спеціальну приховану властивість [[Prototype]] (як зазначено в специфікаціях мови), яка може приймати значення: або null, або мати посилання на інший об’єкт. Цей об’єкт називається “прототип”:',
        URL: 'https://uk.javascript.info/prototype-inheritance'
    },
    {
        question: 'Яка різниця між змінною, яка є: нульовою, невизначеною чи неоголошеною? Як би ви перевірили будь- який із цих станів ?',
        answer: 'null — тип з єдиним значенням null, який означає “пусто” або “не існує”, undefined — тип з єдиним значенням undefined, який означає “не присвоєно”. треба зазначити typeof null == "object" // помилка в мові, Значення null та undefined особливі: вони рівні == лише самим собі і не рівні нічому іншому. Единственно правильным методом выяснения значения null является строгое сравнение переменной с объектом null: x === null, null == undefined// true. null == 0; // false, null< 0;  // false, null > 0; // false, null >= 0; // true (!), null <= 0; // true (!),Неоголошена буде як is not defined якщо через typeof nj undefined',
        URL: 'https://highload.today/null-v-javascript/#4'
    },
    {
        question: 'Що таке закриття, і як/навіщо його використовувати?',
        answer: 'null — тип з єдиним значенням null, який означає “пусто” або “не існує”, undefined — тип з єдиним значенням undefined, який означає “не присвоєно”. треба зазначити typeof null == "object" // помилка в мові, Значення null та undefined особливі: вони рівні == лише самим собі і не рівні нічому іншому. Единственно правильным методом выяснения значения null является строгое сравнение переменной с объектом null: x === null, null == undefined// true. null == 0; // false, null< 0;  // false, null > 0; // false, null >= 0; // true (!), null <= 0; // true (!),Неоголошена буде як is not defined якщо через typeof nj undefined',
        URL: 'https://highload.today/null-v-javascript/#4'
    },
];


export default interviewQuestion;